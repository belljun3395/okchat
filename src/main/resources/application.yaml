spring:
    application:
        name:  okchat
    docker:
        compose:
            enabled: false
    output:
        ansi:
            enabled: ALWAYS  # Enable colored output
    
    # SQL initialization
    sql:
        init:
            mode: always
            continue-on-error: false
    
    # JPA configuration
    jpa:
        hibernate:
            ddl-auto: update
        show-sql: false
    
    # Database configuration (overridable by environment variables)
    datasource:
        url: ${SPRING_DATASOURCE_URL:jdbc:mysql://localhost:13306/okchat?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul}
        driver-class-name: ${SPRING_DATASOURCE_DRIVER_CLASS_NAME:com.mysql.cj.jdbc.Driver}
        username: ${SPRING_DATASOURCE_USERNAME:root}
        password: ${SPRING_DATASOURCE_PASSWORD:root}
        hikari:
            maximum-pool-size: 10
            minimum-idle: 2
            connection-timeout: 30000
            idle-timeout: 600000
            max-lifetime: 1800000
    
    # Redis configuration (overridable by environment variables)
    data:
        redis:
            host: ${SPRING_DATA_REDIS_HOST:localhost}
            port: ${SPRING_DATA_REDIS_PORT:16379}
    
    # Spring Cloud Task
    cloud:
        task:
            enabled: ${SPRING_CLOUD_TASK_ENABLED:true}
            initialize-enabled: ${SPRING_CLOUD_TASK_INITIALIZE_ENABLED:true}
            table-prefix: ${SPRING_CLOUD_TASK_TABLE_PREFIX:TASK_}
            single-instance-enabled: ${SPRING_CLOUD_TASK_SINGLE_INSTANCE_ENABLED:true}
    
    # Spring AI configuration
    ai:
        retry:
            max-attempts: 5
            backoff:
                initial-interval: 2s
                multiplier: 2
                max-interval: 30s
        vectorstore:
            opensearch:
                host: ${SPRING_AI_VECTORSTORE_OPENSEARCH_HOST:localhost}
                port: ${SPRING_AI_VECTORSTORE_OPENSEARCH_PORT:9200}
                scheme: ${SPRING_AI_VECTORSTORE_OPENSEARCH_SCHEME:http}
                username: ${SPRING_AI_VECTORSTORE_OPENSEARCH_USERNAME:}
                password: ${SPRING_AI_VECTORSTORE_OPENSEARCH_PASSWORD:}
                index-name: ${SPRING_AI_VECTORSTORE_OPENSEARCH_INDEX_NAME:vector_store}
                embedding-dimension: ${SPRING_AI_VECTORSTORE_OPENSEARCH_EMBEDDING_DIMENSION:1536}
        openai:
            api-key: ${SPRING_AI_OPENAI_API_KEY:${OPENAI_API_KEY:}}
            embedding:
                model: ${SPRING_AI_OPENAI_EMBEDDING_MODEL:text-embedding-3-small}
            chat:
                options:
                    model: ${SPRING_AI_OPENAI_CHAT_OPTIONS_MODEL:gpt-4.1-mini}
                    stream-usage: true # Enable token usage in streaming responses
        # MCP client disabled for Kubernetes deployment (requires Node.js/npx)
        # mcp:
        #     client:
        #         stdio:
        #             connections:
        #                 sequential-thinking:
        #                     command: npx
        #                     args:
        #                         - "-y"
        #                         - "@modelcontextprotocol/server-sequential-thinking"
        #                 memory:
        #                     command: npx
        #                     args:
        #                         - "-y"
        #                         - "@modelcontextprotocol/server-memory"

# Spring Boot Actuator for Kubernetes health checks
management:
    endpoints:
        web:
            exposure:
                include: health,info,metrics,prometheus
            base-path: /actuator
    endpoint:
        health:
            probes:
                enabled: true
            show-details: when-authorized
    health:
        livenessState:
            enabled: true
        readinessState:
            enabled: true
    prometheus:
        metrics:
            export:
                enabled: true
    tracing:
        sampling:
            probability: 1.0
    otlp:
        tracing:
            endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT:http://localhost:4318/v1/traces}

# Confluence configuration
confluence:
    base-url: ${CONFLUENCE_BASE_URL}
    auth:
        type: BASIC
        email: ${CONFLUENCE_EMAIL:}
        api-token: ${CONFLUENCE_API_TOKEN:}

# Email configuration
email:
    polling:
        interval: 60000
        initial-delay: 10000
    mail:
        protocol: imaps
        timeout: 10000
        connection-timeout: 10000
        debug: true
        debug-auth: true
        ssl:
            enabled: true
            trust: "*"
    providers:
        outlook:
            type: OUTLOOK
            host: outlook.office365.com
            port: 993
            username: ${EMAIL_PROVIDERS_OUTLOOK_USERNAME:your-email.@outlook.com}
            auth-type: OAUTH2
            enabled: ${EMAIL_PROVIDERS_OUTLOOK_ENABLED:false}
            oauth2:
                client-id: ${EMAIL_PROVIDERS_OUTLOOK_OAUTH2_CLIENT_ID:-}
                client-secret: ${EMAIL_PROVIDERS_OUTLOOK_OAUTH2_CLIENT_SECRET:-}
                tenant-id: ${EMAIL_PROVIDERS_OUTLOOK_OAUTH2_TENANT_ID:-}
                scopes:
                    - https://outlook.office365.com/IMAP.AccessAsUser.All  # 이메일 받기
                    - https://outlook.office365.com/SMTP.Send              # 이메일 보내기 (새로 추가)
                    - offline_access                                        # 리프레시 토큰
                redirect-uri: ${EMAIL_PROVIDERS_OUTLOOK_OAUTH2_REDIRECT_URI:http://localhost:8080/oauth2/callback}
        gmail:
            type: GMAIL
            host: imap.gmail.com
            port: 993
            username: ${EMAIL_PROVIDERS_GMAIL_USERNAME:dummy@gmail.com}
            auth-type: OAUTH2
            enabled: ${EMAIL_PROVIDERS_GMAIL_ENABLED:false}
            oauth2:
                client-id: ${EMAIL_PROVIDERS_GMAIL_OAUTH2_CLIENT_ID:dummy-client-id}
                client-secret: ${EMAIL_PROVIDERS_GMAIL_OAUTH2_CLIENT_SECRET:dummy-secret}
                tenant-id: ${EMAIL_PROVIDERS_GMAIL_OAUTH2_TENANT_ID:common}
                scopes:
                    - https://mail.google.com/
                redirect-uri: http://localhost:8080/oauth2/callback

# Task configuration
task:
    confluence-sync:
        enabled: ${TASK_CONFLUENCE_SYNC_ENABLED:false}
    email-polling:
        enabled: ${TASK_EMAIL_POLLING_ENABLED:false}
    metrics-update:
        enabled: ${TASK_METRICS_UPDATE_ENABLED:true}  # Enabled by default
        hourly-interval: ${TASK_METRICS_UPDATE_HOURLY_INTERVAL:60000}  # 1 minute
        daily-interval: ${TASK_METRICS_UPDATE_DAILY_INTERVAL:300000}   # 5 minutes
        initial-delay: ${TASK_METRICS_UPDATE_INITIAL_DELAY:10000}      # 10 seconds

# Hybrid search configuration
search:
    hybrid:
        keyword:
            text-weight: 0.7    # Favor text matching for keywords
            vector-weight: 0.3
        title:
            text-weight: 0.7    # Favor text matching for titles
            vector-weight: 0.3
        content:
            text-weight: 0.4    # Balance text and semantic for content
            vector-weight: 0.6
    fields:
        keyword:
            query-by: "metadata.keywords,metadata.title,content"
            weights: "10,5,1"   # Heavy weight on keywords field
        title:
            query-by: "metadata.title,content,metadata.keywords"
            weights: "10,3,1"   # Heavy weight on title field
        content:
            query-by: "content,metadata.title,metadata.keywords"
            weights: "10,5,3"   # Heavy weight on content field, title and keywords as supporting context
        path:
            query-by: "metadata.path,metadata.title,content"
            weights: "10,5,1"  # Heavy weight on path field

# RAG configuration
rag:
    confluence:
        chunking:
            strategy: RECURSIVE_CHARACTER  # Options: RECURSIVE_CHARACTER, SEMANTIC, SENTENCE_WINDOW
            chunk-size: 512
            chunk-overlap: 50
            min-chunk-size-chars: 350
            min-chunk-length-to-embed: 5
            max-num-chunks: 10000
            keep-separators: true
            semantic-similarity-threshold: 0.5
            sentence-window-size: 3
    rrf:
        k: 60.0
        keyword-weight: 1.0
        title-weight: 2.0  # Increased: Title matching (e.g., "250901") is most important for meeting records
        content-weight: 1.0
        date-boost-factor: 3.0  # Multiply RRF score when document title matches date keywords (e.g., "250804" in query date range)
        path-boost-factor: 2.0  # Multiply RRF score when document path hierarchy matches query intent (e.g., "팀회의" path for meeting queries)

resilience4j:
    circuitbreaker:
        instances:
            chat:
                slidingWindowType: TIME_BASED
                slidingWindowSize: 100
                minimumNumberOfCalls: 10
                failureRateThreshold: 50
                waitDurationInOpenState: 60s
                permittedNumberOfCallsInHalfOpenState: 5
                automaticTransitionFromOpenToHalfOpenEnabled: true
                registerHealthIndicator: true
                recordExceptions:
                    - java.util.concurrent.TimeoutException
                    - java.io.IOException
                    - org.springframework.web.reactive.function.client.WebClientRequestException
    timelimiter:
        instances:
            chat:
                timeoutDuration: 120s